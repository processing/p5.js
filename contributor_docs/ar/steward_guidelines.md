# المتعهدين/ات والمشرفين/ات

سواءً انضممت إلينا حديثًا كمشرف، أو كنت من المشرفين القدامى على مشروع p5.js، أو في أي مرحلة بينهما، يحتوي هذا الدليل على معلومات بالإضافة إلى نصائح وحيل ستساعدك على المساهمة بفعالية في مشروع p5.js. معظم ما هو مكتوب هنا عبارة عن إرشادات (Guidelines) ما لم يُذكر غير ذلك، وهذا يعني أنه يمكنك تكييف الممارسات الموضحة هنا بما يتناسب مع سير عملك.


## جدول المحتويات

- [الـIssues](#الـissues)
  - [تقرير عن Bug](#تقرير-عن-bug)
  - [طلب ميزة جديدة](#طلب-ميزة-جديدة)
  - [تحسين ميزة موجودة](#تحسين-ميزة-موجودة)
  - [النقاش](#النقاش)
- [الـPull Requests](#الـpull-requests)
  - [التعديلات البسيطة](#التعديلات-البسيطة)
  - [إصلاح Bug](#إصلاح-bug)
  - [ميزة جديدة او تحسين ميزة موجودة](#ميزة-جديدة-او-تحسين-ميزة-موجودة)
  - [Dependabot](#dependabot)
- [عملية البناء](#عملية-البناء)
  - [مهمة البناء الأساسية](#مهمة-البناء-الأساسية)
  - [مهام متنوعة](#مهام-متنوعة)
- [عملية الـRelease](#عملية-الـrelease)
- [نصائح وحيل](#نصائح-وحيل)
  - [قوالب الردود](#قوالب-الردود)
  - [GitHub CLI](#github-cli)
  - [إدارة الإشعارات](#إدارة-الإشعارات)
 
---

## الـIssues

نشجع أن تبدأ معظم المساهمات في الكود المصدري بفتح Issue، ولهذا السبب فإن الـIssues هي المكان الذي تتم فيه أغلب النقاشات. الخطوات التي يتعين على المشرف اتباعها عند مراجعة Issue تعتمد على نوعها. الريبو يستخدم [قوالب GitHub للـIssues](https://github.com/processing/p5.js/blob/main/.github/ISSUE_TEMPLATE) بهدف تنظيم أنواع الـIssues المختلفة وتشجيع أصحابها على تقديم جميع المعلومات ذات الصلة بمشكلاتهم. 

أول خطوة عند مراجعة أي Issue عادةً تكون بقراءة النموذج الذي تم تعبئته، وتحديد ما إذا كنت بحاجة إلى معلومات إضافية (على سبيل المثال: في حالة وجود خانات لم يتم تعبئتها أو تم استخدام قالب غير صحيح).


### تقرير عن Bug

يُفترض أن تستخدم الـIssues الخاصة بتقارير الـBugs قالب "Found a bug". ويُعتبر المسار التالي هو النمط المعتاد للتعامل مع تقارير الـBugs:

1. إعادة إنتاج الـBug
   - الهدف من القالب هو توفير معلومات كافية للمشرف حتى يتمكن من محاولة إعادة إنتاج الـBug المذكور.
   - إذا كان الـBug المبلّغ عنه لا يخص الريبو الذي تم فتحه فيه (سواء كان p5.js أو p5.js-website أو غيره):
     - انقل الـIssue إلى الريبو المناسب إذا كان لديك الصلاحية.
     - إن لم تكن تملك الصلاحية، اترك تعليقًا يوضح أين يجب رفع التقرير (مع توفير رابط مباشر)، ثم أغلق الـIssue.
   - أول خطوة عند مراجعة تقرير الـBug هي التأكد من وجود معلومات كافية لمحاولة إعادة إنتاجه، وإذا توفرت، قم بالمحاولة.

2. إذا أمكن إعادة إنتاج الـBug:
   - قد يتطلب الأمر نقاشًا لتحديد أفضل طريقة لإصلاح الـBug. أحيانًا تكون الطريقة واضحة وأحيانًا تكون معقدة. يُرجى الرجوع إلى [مبادئ تصميم p5.js](./contributor_guidelines.md#مبادئ-تصميم-البرمجيات) عند اتخاذ القرار في كل حالة.
   - إذا أشار صاحب الـIssue في التقرير إلى استعداده للمساهمة في الحل:
     - وافق على أن يقوم هو بإصلاح الـBug بترك تعليق وتعيينه على الـIssue. يمكنك تعيينه باستخدام زر الإعدادات (⚙️) بجانب "Assignee".
   - إذا لم يرغب صاحب الـIssue في المساهمة بالإصلاح:
     - اترك تعليقًا يؤكد أن الـBug تم إعادة إنتاجه.
     - حاول إصلاحه بنفسك أو أضف وسم `help wanted` للإشارة إلى أن هذا الـIssue بحاجة إلى مساهمة.

3. إذا تعذرت إعادة إنتاج الـBug:
   - اطلب معلومات إضافية إذا لم تكن متوفرة بالفعل في القالب (مثل إصدار p5.js، إصدار المتصفح، نظام التشغيل...إلخ).
   - إذا كان بيئة الاختبار لديك تختلف عن المذكورة في التقرير (مثال: متصفح أو نظام تشغيل مختلف):
     - اترك تعليقًا توضح فيه أنك لم تستطع إعادة إنتاج الـBug في بيئتك.
     - أضف وسم `help wanted` واطلب من شخص آخر يملك نفس البيئة المذكورة في التقرير أن يحاول إعادة إنتاج الـBug.
   - أحيانًا تحدث الـBugs في محرر الويب فقط وليس عند الاختبار محليًا. في هذه الحالة، يجب إعادة توجيه الـIssue إلى ريبو [الـWeb Editor](https://github.com/processing/p5.js-web-editor).
   - إذا نجحت إعادة الإنتاج لاحقًا، ارجع إلى الخطوة 2.

4. إذا كان سبب الـBug هو الكود الذي قدمه المستخدم وليس بسبب سلوك p5.js:
   - حدد ما إذا كان من الممكن تحسين توثيق p5.js أو الكود أو نظام الأخطاء الودية (friendly error system) لتجنب تكرار نفس الخطأ.
   - قم بتوجيه المستخدم بلطف إلى [المنتدى](https://discourse.processing.org/) أو [Discord](https://discord.com/invite/SHQ8dH25r9) في حال عدم وجود أي تعديلات لازمة في p5.js، ثم أغلق الـIssue.
  

### طلب ميزة جديدة

يُفترض أن تستخدم الـIssues الخاصة بطلبات الميزات الجديدة قالب "New Feature Request". والمسار التالي هو النمط المعتاد للتعامل مع طلبات الميزات:

1. كجزء من التزام p5.js بزيادة الوصول، يجب أن يوضح طلب الميزة كيف يساهم في زيادة إتاحة p5.js إلى المجتمعات التي تم تهميشها تاريخيًا في هذا المجال. يمكن العثور على المزيد من التفاصيل [هنا](access.md).
   - إذا لم يُملأ حقل "زيادة الوصول" بشكل كافٍ في الطلب، يمكنك أن تطلب من صاحب الـIssue توضيح كيف تزيد هذه الميزة من الوصول.
   - يمكن لأي عضو آخر في المجتمع (بما في ذلك المشرفون على المراجعة) أن يضيف بيانًا حول تأثير الميزة على زيادة الوصول.

2. يتم تقييم طلب الميزة الجديدة للنظر في إدراجه بناءً على المعايير التالية:
   - هل الميزة المقترحة تناسب نطاق المشروع ومبادئ [تصميم p5.js](./contributor_guidelines.md#مبادئ-تصميم-البرمجيات)؟
     - على سبيل المثال، قد يتم النظر في طلب إضافة شكل جديد للرسم، بينما طلب تبني بروتوكول إنترنت الأشياء (IOT) في المتصفح سيكون غالبًا خارج النطاق.
     - بشكل عام، يجب أن يظل نطاق p5.js ضيقًا نسبيًا لتجنب التضخم المفرط الناتج عن إضافة ميزات نادرًا ما تُستخدم.
     - إذا لم تكن الميزة المقترحة مناسبة لنطاق p5.js، يمكنك اقتراح أن يقوم صاحب الطلب بتنفيذها على شكل مكتبة إضافية (Addon Library).
     - إذا لم يكن من الواضح ما إذا كانت الميزة مناسبة أو لا، فمن الجيد أحيانًا اقتراح تنفيذها كمكتبة إضافية كتجربة إثبات المفهوم (Proof of Concept). هذا يمنح المستخدمين طريقة لتجربة الميزة ويقدم مثالًا عمليًا أكثر على فائدتها وأهميتها، كما أن المكتبة الإضافية ليست بحاجة لأن تكون مكتملة مثل الميزات المدمجة في صلب p5.js. وإذا ثبتت أهميتها لاحقًا، يمكن دمجها في الكود الأساسي.

   - هل من المحتمل أن تسبب الميزة تغييرات جذرية؟
     - هل ستتعارض مع دوال أو متغيرات p5.js الحالية؟
     - هل ستتعارض مع الرسومات (Sketches) الموجودة مسبقًا المكتوبة باستخدام p5.js؟
     - تعتبر الميزات التي قد تسبب تعارضات مثل هذه تغييرات جذرية. وبدون [إصدار رئيسي جديد](https://docs.npmjs.com/about-semantic-versioning)، يجب تجنب إدخال تغييرات جذرية على p5.js.

   - هل يمكن تنفيذ الميزة المقترحة باستخدام الوظائف الحالية في p5.js أو باستخدام أكواد JavaScript الأصلية البسيطة أو مكتبات أخرى سهلة الاستخدام؟
     - على سبيل المثال، بدلاً من إضافة دالة p5.js تجمع بين مجموعة من النصوص مثل `join(["Hello", "world!"])`، يُفضل استخدام الدالة الأصلية في JavaScript:  
     `["Hello", "world!"].join()`.

3. إذا تم استيفاء متطلبات الوصول والمعايير الأخرى، فيجب أن يوافق مشرفان أو اثنان من المسؤولين عن الصيانة (Maintainers) على الأقل على طلب الميزة قبل أن يبدأ العمل على إعداد Pull Request. عملية مراجعة الـPR الخاصة بالميزات الجديدة موضحة أدناه.


### تحسين ميزة موجودة

يُفترض أن تستخدم الـIssues الخاصة بتحسين الميزات القائمة قالب "Existing Feature Enhancement". والعملية مشابهة جدًا لطلبات الميزات الجديدة، مع وجود اختلاف بسيط بينهما. أحيانًا قد يكون من الصعب التمييز بين طلب ميزة جديدة وتحسين ميزة قائمة. بشكل عام، تحسين الميزة يتعامل مع الوظائف الموجودة مسبقًا في p5.js، بينما طلب الميزة الجديدة عادةً يطلب إضافة وظائف جديدة بالكامل.

1. على غرار طلبات الميزات الجديدة، لا يُقبل تحسين الميزة إلا إذا ساهم في زيادة الإتاحة إلى p5.js. راجع النقطة 1 في [القسم السابق](#طلب-ميزة-جديدة).

2. معايير قبول تحسين الميزة مشابهة لمعايير قبول الميزات الجديدة، لكن مع التركيز بشكل خاص على احتمال حدوث تغييرات جذرية (Breaking Changes).
   - إذا كان التحسين يتضمن تعديل دوال موجودة، فيجب أن تظل جميع التوقيعات (Signatures) الصالحة والموثقة لهذه الدوال تعمل بنفس الطريقة دون أي تغييرات.

3. يجب أن يحصل تحسين الميزة على موافقة مشرف (Steward) واحد على الأقل أو أحد مسؤولي الصيانة (Maintainer) قبل أن يبدأ العمل على إعداد الـPull Request. عملية مراجعة الـPR الخاصة بتحسين الميزات موضحة أدناه.


### النقاش

هذا النوع من الـIssues يستخدم قالبًا بسيطًا تحت اسم ("Discussion")، ويُفترض استخدامه لجمع الآراء والملاحظات حول موضوع عام قبل تحويله إلى شيء أكثر تحديدًا مثل طلب ميزة جديدة. يمكن إغلاق هذه الـIssues بعد انتهاء النقاش وإنشاء الـIssues الأكثر تحديدًا الناتجة عن هذا النقاش.

- إذا تم فتح Issue على أنها نقاش، لكنها في الواقع بلاغ عن bug مثلًا، فيجب تعديل التصنيف (Label) إلى التصنيف المناسب، وإزالة تصنيف "discussion". كما يجب طلب أي معلومات إضافية حول الـbug من صاحب الـIssue إذا لم تكن موجودة بالفعل.
- إذا تم فتح Issue على أنها نقاش، لكنها غير مرتبطة بالمساهمة في الكود المصدري أو بعمل ريبوز GitHub أو عملية المساهمة أو مجتمع المساهمين، فيجب إعادة توجيه صاحبها إلى المنتدى أو سيرفر الـDiscord، ثم إغلاق الـIssue.
- إذا كانت ذات صلة، فمن الأفضل إضافة تصنيفات إضافية (Labels) إلى الـIssues من نوع النقاش لتوضيح نوع النقاش بشكل سريع بمجرد النظر.


---


## الـPull Requests

تقريبًا جميع المساهمات في الكود المصدري في ريبوز p5.js تتم عبر الـPull Requests. على الرغم من أن المشرفين لديهم صلاحية الدفع المباشر (Push Access) إلى الريبو، إلا أنه من الأفضل لهم اتباع نفس العملية: (Issue → Pull Request → Review) عند المساهمة بالكود. فيما يلي الخطوات المتبعة لمراجعة الـPull Request:

- يمكن العثور على قالب الـPull Request [هنا](https://github.com/processing/p5.js/blob/main/.github/PULL_REQUEST_TEMPLATE.md).
- معظم الـPull Requests يجب أن تكون مرتبطة مسبقًا بـIssue مفتوح وتمت مناقشته أولًا، مما يعني أنه يجب اتباع [مسار العمل الخاص بالـIssues](#الـissues) قبل أن يقوم أي مشرف أو مدير بمراجعة الـPull Request.
    - الحالات الوحيدة التي لا ينطبق عليها هذا الأمر هي التعديلات البسيطة جدًا مثل تصحيح الأخطاء الإملائية، والتي لا تتطلب فتح Issue ويمكن لأي شخص لديه صلاحية الدمج (Merge Access) في الريبو دمجها، حتى لو لم يكن مشرفًا على هذا الجزء.
    - بالرغم من وجود هذا الاستثناء، إلا أننا نفضل عمليًا تشجيع جميع المساهمين على فتح Issue أولًا. بمعنى آخر، في حالة الشك حول ما إذا كان الاستثناء ينطبق، فمن الأفضل فتح Issue على أي حال.
- إذا كان الـPull Request لا يحل المشكلة المشار إليها بالكامل، يمكنك تعديل المنشور الأصلي وتغيير "Resolve #IssueNumber" إلى "Addresses #IssueNumber" حتى لا يتم إغلاق الـIssue الأصلي تلقائيًا عند دمج الـPR.


### التعديلات البسيطة

التعديلات البسيطة، مثل تصحيح خطأ إملائي صغير، يمكن دمجها مباشرةً من قِبل أي شخص لديه صلاحية الدمج (Merge Access).  

تأكد من علامة التبويب **"الملفات المعدلة"** (Files Changed) في الـPull Request للتأكد من أن اختبارات CI التلقائية قد نجحت.

![تبويب "الملفات المعدلة" عند عرض الـPull Request على GitHub](../images/files-changed.png)

![مؤشر "جميع الاختبارات نجحت" على الـPull Request في GitHub، مميزًا فوق زر الدمج](../images/all-checks-passed.png)


### إصلاح Bug

1. يجب أن تتم مراجعة إصلاح الBugs من قبل المشرف المسؤول عن المجال المرتبط، ويفضّل أن يكون نفس المشرف الذي وافق على الـIssue الخاصة بهذا الخطأ في البداية.
2. يمكن استخدام تبويب **"الملفات المعدلة"** (Files Changed) في الـPull Request لإجراء مراجعة أولية والتأكد من أن الإصلاح تم تنفيذه كما نوقش في الـIssue.
3. يجب اختبار الـPull Request محليًا كلما أمكن وكان ذلك مناسبًا. أداة GitHub CLI يمكن أن تساعد في تسهيل بعض الخطوات. (راجع المزيد في [نصائح وحيل](#نصائح-وحيل)).

   - [ ] يجب أن يعالج الإصلاح المشكلة الأصلية بشكل كافٍ.
   - [ ] يجب ألا يغير الإصلاح أي سلوكيات قائمة إلا إذا تم الاتفاق على ذلك في الـIssue.
   - [ ] يجب ألا يؤثر الإصلاح سلبًا على أداء مكتبة p5.js.
   - [ ] يجب ألا يؤثر الإصلاح على إتاحة مكتبة p5.js.
   - [ ] يجب أن يلتزم الإصلاح بمعايير كتابة الشيفرة الحديثة في JavaScript.
   - [ ] يجب أن ينجح الإصلاح في جميع الاختبارات التلقائية، وأن يتضمن اختبارات جديدة إذا كان ذلك مناسبًا.

4. إذا كانت هناك حاجة إلى أي تعديلات إضافية، يمكن إضافة تعليقات مباشرة على الأسطر ذات الصلة كما هو موضح [هنا](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request).

   - يمكن أيضًا استخدام **مربع اقتراح** (Suggestion Block) لتقديم تعديلات محددة:  
     ![زر "اقتراح التغيير" أثناء كتابة تعليق على كود في GitHub Pull Request](../images/suggest-change.png)  
     ![تغيير مقترح يظهر داخل سياج كود مع وسم "suggestion"](../images/suggested-value-change.png)  
     ![معاينة التغيير المقترح على شكل diff](../images/suggestion-preview.png)

   - إذا كانت هناك تعديلات كثيرة مطلوبة، لا تضع تعليقات على كل سطر على حدة، بل استخدم الطريقة الموثقة [هنا](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request) لكتابة تعليق واحد يشمل عدة أسطر، ثم طلب التعديلات دفعة واحدة.
   - إذا كانت التعليقات بغرض التوضيح أو النقاش فقط، اختر "Comment" بدلًا من "Request changes":  
     ![خيار "Comment" محاط بدائرة داخل قائمة إنهاء المراجعة في GitHub](../images/comment-review.png)

5. بمجرد اكتمال مراجعة الـPR وعدم الحاجة لأي تغييرات إضافية، يمكن للمشرف (Steward) وضع علامة **"Approved"** عبر اختيار "Approve" في الخطوة السابقة، مع أو بدون إضافة تعليقات إضافية. بعد ذلك يمكنه:

   - طلب مراجعة إضافية من مشرف أو Maintainer آخر (اختياري).
   - دمج الـPR إذا كان لديه صلاحية الدمج.
   - أو طلب الدمج من أحد الـMaintainers.

6. يجب استدعاء بوت [@all-contributors](https://allcontributors.org/docs/en/emoji-key) لإضافة أي مساهمين جدد إلى قائمة المساهمين في ملف README.md. يمكن تحديد نوع المساهمة في مكان `[contribution type]` كما هو موضح أدناه. قائمة أنواع المساهمات المتاحة بالكامل موجودة في الرابط أعلاه.

```
@all-contributors please add @[GitHub handle] for [contribution type]
```


### ميزة جديدة او تحسين ميزة موجودة

عملية مراجعة ودمج الـPull Request الخاصة بالميزات الجديدة أو تحسين الميزات القائمة تشبه بشكل كبير عملية مراجعة إصلاح الأخطاء (Bug Fixes)، مع فارق واحد مهم:

- يجب أن تتم مراجعة الـPull Request والموافقة عليها من قبل **مشرفين** أو **Maintainers** على الأقل قبل أن يتم دمجها.



### Dependabot

طلبات الـPull Requests من Dependabot عادةً لا تكون مرئية إلا لمسؤولي الريبو، لذلك إذا لم تكن مسؤولاً، يمكنك تجاهل هذا القسم.

- يمكن دمج طلبات Dependabot مباشرةً إذا كان التحديث هو تحديث **Patch** وفقًا [لـSemVer](https://semver.org/) واجتاز الفحوصات التلقائية (CI).
- طلبات Dependabot التي تحتوي على تحديث **Minor** يمكن عادةً دمجها مباشرةً طالما اجتازت الفحوصات التلقائية (CI). يُفضَّل إجراء مراجعة سريعة على سجل التغييرات (changelog) الخاص بالتبعية المحدثة.
- طلبات Dependabot التي تحتوي على تحديث **Major** قد تؤثر على عملية البناء (Build Process) أو على وظائف p5.js نفسها. في هذه الحالة، يُفضَّل أن يقوم المراجع بقراءة سجل التغييرات (changelog) من الإصدار الحالي إلى الإصدار المستهدف إن أمكن، بالإضافة إلى اختبار التغييرات محليًا للتأكد من أن كل شيء يعمل بشكل سليم وإجراء أي تعديلات مطلوبة في حالة وجود تغييرات جوهرية (Breaking Changes) في التبعية.
- العديد من التبعيات تقوم بزيادة رقم الإصدار الرئيسي (Major Version) فقط لأنها توقفت عن دعم الإصدارات القديمة جدًا من Node.js. في كثير من الحالات، تحديث النسخ الرئيسية (Major) لا يعني بالضرورة وجود تغييرات جوهرية (Breaking Changes) في واجهة برمجة التطبيقات (API) الخاصة بالتبعية.

---


## عملية البناء

هذا القسم لن يغطي إعدادات البناء العامة أو الأوامر، بل سيتناول التفاصيل الخاصة بما يحدث خلف الكواليس. يُرجى الاطلاع على [إرشادات المساهمة](contributor_guidelines.md#working-on-p5js-codebase) للحصول على معلومات أكثر تفصيلًا حول عملية البناء.

الملف `Gruntfile.js` يحتوي على تعريفات البناء الرئيسية الخاصة بـp5.js. من بين الأدوات المختلفة المستخدمة لبناء المكتبة والتوثيق: Grunt وBrowserify وYUIDoc وESLint وBabel وUglify وMocha، وغيرها. قد يكون من المفيد أن نبدأ بمهمة `default` ثم نعود للخلف لفهم باقي المهام. في هذه المرحلة، قد يكون من المفيد فتح ملف `Gruntfile.js` أثناء قراءة الشرح أدناه.


### مهمة البناء الرئيسية

```
grunt.registerTask('default', ['lint', 'test']);
```

عند تشغيل الأمر `grunt` أو السكربت `npm test`، يتم تنفيذ المهمة الافتراضية التي تتكون من `lint` ثم `test`.

#### مهمة `lint`

```
grunt.registerTask('lint', ['lint:source', 'lint:samples']);
```

مهمة `lint` تتكون من مهمتين فرعيتين: `lint:source` و`lint:samples`. المهمة `lint:source` تنقسم أيضًا إلى ثلاث مهام فرعية أخرى: `eslint:build` و`eslint:source` و`eslint:test`، والتي تستخدم ESLint لفحص سكربتات البناء والكود المصدري وكود الاختبارات.

مهمة `lint:samples` تقوم أولًا بتشغيل المهمة `yui`، والتي تتكون من `yuidoc:prod` و`clean:reference` و`minjson`، حيث تقوم باستخراج التوثيق من الكود المصدري إلى مستند JSON، ثم حذف الملفات غير المستخدمة من الخطوة السابقة، وأخيرًا ضغط ملف JSON الناتج إلى `data.min.json`.

بعد ذلك في `lint:samples` يتم تشغيل `eslint-samples:source`، وهي مهمة مخصصة مكتوبة داخل [../tasks/build/eslint-samples.js](../tasks/build/eslint-samples.js)؛ تقوم هذه المهمة بتشغيل ESLint لفحص أكواد الأمثلة التوثيقية للتأكد من اتباعها لنفس معايير كتابة الكود الخاصة بـp5.js (تُشغّل `yui` أولًا لأننا نحتاج إلى ملف JSON ليتم بناؤه قبل التحقق من الأمثلة).

#### مهمة `test`

```js
grunt.registerTask('test', [
  'build',
  'connect:server',
  'mochaChrome',
  'mochaTest',
  'nyc:report'
]);
```

أولًا، لنلقِ نظرة على مهمة `build` ضمن `test`.

```js
grunt.registerTask('build', [
  'browserify',
  'browserify:min',
  'uglify',
  'browserify:test'
]);
```

المهام التي تبدأ بـ`browserify` مُعرفة في الملف [../tasks/build/browserify.js](../tasks/build/browserify.js). جميعها تتبع خطوات متشابهة مع بعض الاختلافات البسيطة. هذه هي الخطوات الأساسية لبناء مكتبة p5.js كاملة من ملفات الكود المصدري المتعددة في ملف واحد:

- `browserify` يبني p5.js، بينما `browserify:min` يبني ملفًا وسيطًا ليتم ضغطه في الخطوة التالية. الفرق بين `browserify` و`browserify:min` هو أن الأخير لا يحتوي على البيانات اللازمة لعمل FES.
- `uglify` يأخذ الملف الناتج عن `browserify:min` ويضغطه إلى الملف النهائي `p5.min.js` (إعدادات هذه الخطوة موجودة في `Gruntfile.js` الرئيسي).
- `browserify:test` يبني نسخة مطابقة لـp5.js الكاملة مع إضافة كود مخصص لتغطية الاختبارات (باستخدام [Istanbul](https://istanbul.js.org/)).

أولًا، يتم استبدال أكواد `fs.readFileSync()` الخاصة بـnode.js بمحتوى الملف الفعلي باستخدام `brfs-babel`. تُستخدم هذه الخطوة بشكل رئيسي في كود WebGL لإدراج أكواد الـshader المخزنة في ملفات منفصلة.

بعد ذلك، يتم تحويل الكود المصدري وجميع التبعيات من `node_modules` باستخدام Babel ليتوافق مع متطلبات [Browserslist](https://browsersl.ist/) المحددة في `package.json`، وكذلك لتحويل أوامر الاستيراد `import` من ES6 إلى `require()` التي يفهمها `browserify`. هذا يُتيح لنا استخدام الصياغات الأحدث في ES6 وما بعدها بدون القلق من توافق المتصفحات.

بعد التجميع، وقبل كتابة الكود المجمع إلى الملف، يتم تمريره عبر `pretty-fast` لتنظيف التنسيق وجعل المخرجات النهائية أكثر اتساقًا (نتوقع أن يكون كود p5.js قابلاً للقراءة والتفحص عند الحاجة).

بعض التفاصيل الصغيرة الأخرى لم تُذكر هنا؛ يمكنك مراجعة ملف تعريف بناء `browserify` للحصول على تفاصيل أدق.

```
connect:server
```

هذه الخطوة تقوم بتشغيل خادم محلي يستضيف ملفات الاختبار والملفات المصدرية المبنية حتى يتم تشغيل الاختبارات الآلية في Chrome.

```
mochaChrome
```

هذه الخطوة مُعرفة في [../tasks/test/mocha-chrome.js](../tasks/test/mocha-chrome.js). تقوم بتشغيل نسخة رأسية (headless) من Chrome باستخدام Puppeteer وتنفذ الاختبارات المرتبطة بملفات HTML داخل مجلد `./test`، والتي تشمل اختبار النسخة غير المضغوطة والمضغوطة من المكتبة مقابل مجموعات اختبارات الوحدة، وكذلك اختبار جميع أمثلة التوثيق.

```
mochaTest
```

تختلف هذه الخطوة عن `mochaChrome` لأنها تعمل داخل بيئة node.js بدلاً من Chrome وتختبر مجموعة صغيرة فقط من الميزات في المكتبة. معظم ميزات p5.js تتطلب بيئة متصفح، لذلك يُفضل توسيع هذه الاختبارات فقط للميزات التي لا تحتاج متصفح.

```
nyc:report
```

أخيرًا، بعد اكتمال جميع عمليات البناء والاختبار، تقوم هذه الخطوة بجمع تقرير تغطية الاختبارات أثناء تنفيذ `mochaChrome` وتطبع بيانات التغطية إلى الطرفية. الغرض الأساسي من تغطية الاختبارات في p5.js هو المتابعة والحصول على بيانات إضافية؛ الوصول إلى 100% تغطية ليس هدفًا.

وهكذا نكون قد غطينا المهمة الافتراضية في إعدادات `Gruntfile.js`!


### المهام المتنوعة

يمكن تشغيل أي خطوة مباشرة باستخدام:

```
npx grunt [الخطوة]
```

هناك أيضًا بعض المهام الإضافية التي لم يتم ذكرها أعلاه لكنها قد تكون مفيدة في بعض الحالات.

```
grunt yui:dev
```

هذه المهمة تقوم بتشغيل عمليات بناء التوثيق والمكتبة التي ذُكرت سابقًا، ثم تقوم بتشغيل خادم ويب محلي يعرض نسخة مشابهة وظيفيًا لصفحة التوثيق المرجعي التي تجدها على الموقع، على الرابط:  
[http://localhost:9001/docs/reference/](http://localhost:9001/docs/reference/).  
بعد ذلك، تراقب الكود المصدري لاكتشاف أي تغييرات، وتقوم بإعادة بناء التوثيق والمكتبة بشكل تلقائي.

تعتبر `grunt yui:dev` مفيدة جدًا عند العمل على التوثيق الداخلي (inline documentation) لأنه لن يكون عليك نسخ الملفات المبنية من ريبو p5.js إلى ريبو p5.js-website المحلي وإعادة بناء الموقع في كل مرة تقوم فيها بتغيير. بدلًا من ذلك، يمكنك معاينة تغييراتك مباشرة عبر هذه النسخة المبسطة من صفحة التوثيق المرجعي في المتصفح. بهذه الطريقة، يمكنك أيضًا التأكد من أن التغييرات التي قمت بها ستظهر بشكل صحيح على الموقع لاحقًا.

تنبيه: هذه الطريقة مخصصة فقط للتعديلات على التوثيق الداخلي (inline documentation)، أما التغييرات على صفحة التوثيق المرجعي نفسها (بما في ذلك التنسيقات والتخطيط)، فيجب تنفيذها واختبارها في ريبو الموقع (p5.js-website repository).

---

```
grunt watch
grunt watch:main
grunt watch:quick
```

مهام `watch` تقوم بمراقبة مجموعة من الملفات لاكتشاف التغييرات، ثم تقوم بتشغيل المهام المرتبطة بها لبناء التوثيق أو المكتبة بناءً على الملفات التي تم تغييرها.  
كل هذه المهام تؤدي نفس الفكرة، مع اختلاف نطاق العمل فقط.

- المهمة `watch` تقوم بتشغيل جميع عمليات البناء والاختبار، بشكل مشابه للمهمة الافتراضية `default`، عند اكتشاف تغييرات في الكود المصدري.
- المهمة `watch:main` تقوم ببناء المكتبة وتشغيل الاختبارات، لكنها **لا تقوم بإعادة بناء التوثيق** عند اكتشاف تغييرات.
- المهمة `watch:quick` تقوم فقط ببناء المكتبة عند اكتشاف تغييرات، بدون تشغيل أي اختبارات أو إعادة بناء التوثيق.

اعتمادًا على طبيعة العمل الذي تقوم به، اختيار المهمة الأنسب (الأقل شمولًا) يمكن أن يوفر عليك الوقت، بدلاً من تشغيل عملية البناء يدويًا بعد كل تعديل.

---

## عملية الـRelease

يرجى الاطلاع على الملف [release_process.md](release_process.md).

---

